# 动态规划

## 解题过程

* 我是谁
* 我从哪里来
* 我要到哪里去

## DP实现方式

* 线性递推
* 记忆化搜索递归

## 例题

### 例题1 切割钢条

#### 题目地址

无

#### 题面

    钢条长度为n，可以切割。最后，对于每个长度k，有对应价值Wk.问切割结束后，所有钢条的价值和最大是多少。

#### 题解

状态：dp[i]表示在i剁了一刀，[1，i]这段区间产生的最大价值。

从哪里来：对于所有的k，dp[i-k]都能到达dp[i]转移方程：dp[i]=max{dp[i-k]+w[k]}

#### 代码演示

无

### 例2 过河卒 (NOIP2002普及)

#### 题目地址

https://www.luogu.org/problemnew/show/P1002

#### 题面

    棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒"。
    棋盘用坐标表示，A点（0，0）、B点（n，m）（n，m为不超过20的整数），同样马的位置坐标是需要给出的。
    现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

#### 题解

`dp[i][j]=dp[i-1][j]+dp[i][j-1]`

#### 代码演示

`待补充`

### 例2 采药 (NOIP2005普及)

#### 题目地址

https://www.luogu.org/problemnew/show/P1048

#### 题面

    辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最 有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
    如果你是辰辰，你能完成这个任务吗？

#### 题解

典型的01背包模板
`dp[i][j]=max(dp[i-1][j-w[i]]+val[i],dp[i-1][j])`

#### 代码演示

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;
int w[105],val[105];
int dp[105][1005];
int main()
{
    int n,m,res=-1;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&w[i],&val[i]);
    }
    for(int i=1;i<=m;i++) 
        for(int j=n;j>=0;j--)  
        {
            if(j>=w[i])
            {
                dp[i][j]=max(dp[i-1][j-w[i]]+val[i],dp[i-1][j]);
            }  
            else
            {
                dp[i][j]=dp[i-1][j];
            }              
        }
    printf("%d",dp[m][n]);
    return 0;
}
```

#### 总结

背包问题：`dp[k][w] : 用了k个空间所得到w个价值`

转移方程：`dp[i][j]=max(dp[i-1][j-w[i]]+val[i],dp[i-1][j])`

背包优化： 原理->新的由旧的更新而来,滚动数组优化

### 例3 装箱问题(NOIP2001 普及组)

#### 题目地址

https://www.luogu.org/problemnew/show/P1049

#### 题面

    有一个箱子容量为V（正整数，0V≤20000），同时有n个物品（0<n≤30，每个物品有一个体积（正整数）。
    要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

#### 题解

 f (m) = max ( f ( m - w[i] ) + w[i], f (m) )

#### 代码演示

```cpp
#include<cstdio>
using namespace std;
int m,n;//m即箱子容量V
int f[20010];
int w[40];
int main(){
    int i,j;
    scanf("%d%d",&m,&n);
    for(i=1;i<=n;i++){
        scanf("%d",&w[i]);
    }
    for(i=1;i<=n;i++){
        for(j=m;j>=w[i];j--){
            //注意：这里必须是从m到w[i]，否则一个物体会被多次装入箱子，见例1
            if(f[j]<f[j-w[i]]+w[i]){
                f[j]=f[j-w[i]]+w[i];
            }
        }
    }
    printf("%d\n",m-f[m]);
}
```

### 例4 开心的金明 (NOIP2006 普及组)

#### 题目地址

https://www.luogu.org/problemnew/show/P1060

#### 题面

    金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1-5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过V元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
    设第件物品的价格为v1j]，重要度为uwj]，共选中了k件物品，编号依次为1，j2，…，jk，则所求的总和为：
    v[j]×w[j1]+v[j2]×w[j2]+.……+v[jk]×w[jk]。
    请你帮助金明设计一个满足要求的购物单。

#### 题解

还是背包问题。

#### 代码演示

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int w[30],v[30],f[50000];//w数组为重要度，v数组为money，f是用来dp的数组
int n,m;//n是总物品个数，m是总钱数
int main()
{
    cin>>m>>n;//输入
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
        w[i]*=v[i];//w数组在这里意义变为总收获（重要度*money）
    }
       //01背包（参照第二类模板“一维数组优化”）
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=v[i];j--)//注意从m开始
        {
            if(j>=v[i])
            {
                f[j]=max(f[j],f[j-v[i]]+w[i]);//dp
            }
        }
    }
    cout<<f[m]<<endl;//背包大小为m时最大值
    return 0;
} 
```

### 例5 守望者的逃离 (NOIP2007 普及组)

#### 题目地址

https://www.luogu.org/problemnew/show/P1095

#### 题面

    恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。守望者的跑步速度为17m/s，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。
    现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离S，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。
    注意：守望者跑步、闪烁或休息活动均以秒（s）为单位，且每次活动的持续时间为整数秒。距离的单位为米（m）。

#### 题解

DP问题

#### 代码演示

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int dp[300001];
int main(){
    int m,s,t;
    scanf("%d%d%d",&m,&s,&t);
    for(int i=1;i<=t;i++){//处理闪烁法术
        if(m>=10)dp[i]=dp[i-1]+60,m-=10;//如果能用，就用
        else dp[i]=dp[i-1],m+=4;//否则休息
    }
    for(int i=1;i<=t;i++){dp[i]=max(dp[i],dp[i-1]+17);
    //处理跑步，dp[i]为使用法术和跑步的最大值（最优）
    if(dp[i]>=s){printf("Yes\n%d",i);return 0;}//如果超过了距离s，就成功了，输出yes
    }printf("No\n%d",dp[t]);//没成功，输出no
    return 0;
}
```

